# D3.js

link: [D3.js 的 v5 版本入门教程（第一章）—— 如何在项目中使用 D3.js](https://blog.csdn.net/qq_34414916/article/details/80026180)
[D3.js 的 V5 版本-Vue 框架中使用(第一章) ---SVG 基础](https://blog.csdn.net/davidPan1234/article/details/80704302)

[矩形树状图](https://codepen.io/wlei/pen/YveRmB)
## 理解 Update、Enter、Exit

![](https://img-blog.csdn.net/20180421121704602)

```html
<body>
    <p>dog</p>
    <p>cat</p>
    <p>pig</p>
    <script>
        var dataset = [3, 6, 9, 12, 15];
        var p = d3.select("body").selectAll("p");
        var update = p.data(dataset) //绑定数据,并得到update部分
        var enter = update.enter(); //得到enter部分
        //下面检验是否真的得到
        //对于update的处理
        update.text(function (d, i) {
            return "update: " + d + ",index: " + i;
        })
        //对于enter的处理    	//注意，这里需要先添加足够多的<p>，然后在添加文本
        var pEnter = enter.append("p") //添加足够多的<p>
        pEnter.text(function (d, i) {
            return "enter: " + d + ",index: " + i;
        })
    </script>
</body>


<body>
    <p>dog</p>
    <p>cat</p>
    <p>pig</p>
    <p>rat</p>

    <script>
    	var dataset = [3,6];
    	var p = d3.select("body")
    		.selectAll("p");
    	var update = p.data(dataset)//绑定数据,并得到update部分
    	var exit = update.exit();//得到exit部分
    	//下面检验是否真的得到
    	//对于update的处理
    	update.text(function(d,i){
    		return "update: "+d+",index: "+i;
    	})
    	//对于exit的处理通常是删除 ，但在这里我并没有这么做
    	exit.text(function(d,i){
    		return "exit";
    	})
    </script>
  </body>
```

对于 exit 部分的处理通常是删除`exit.remove()`

## 简单的矩形

```js
var marge = { top: 60, bottom: 60, left: 60, right: 60 }; //设置边距
var dataset = [250, 210, 170, 130, 90]; //数据（表示矩形的宽度）
var svg = d3.select("#testSvg3"); //得到svg画布
console.log(svg);
var g = svg
  .append("g") //定义一个用来装整个图表的一个分组，并设置他的位置
  .attr("transform", "translate(" + marge.top + "," + marge.left + ")");
var rectHeight = 30; //设置每一个矩形的高度

g.selectAll("rect")
  .data(dataset)
  .enter()
  .append("rect")
  .attr("x", 30) //设置左上点的x
  .attr("y", function(d, i) {
    //设置左上点的y
    return i * rectHeight;
  })
  .attr("width", function(d) {
    //设置宽
    return d;
  })
  .attr("height", rectHeight - 5) //设置长
  .attr("fill", "blue"); //颜色填充
```

## 比例尺

比例尺在 D3.js 中是一个很重要的东西，我们可以这样理解 d3.js 中的比例尺——一种映射关系，从`domain`映射到`range`域（为什么会是 domain 和 range 呢？等一下你就会看到，因为我们在建立比例尺是常常会用到`domain()和range()`两个函数，当然不是绝对的，D3 中有很多类型的比例尺）

- 线性比例尺
- 序数比例尺

### 线性比例

    domain域和range域都可以连续变化

```html
<body>
  <script>
    	var dataset = [1.2, 2.3, 0.9, 1.5, 3.3];
    	var min = d3.min(dataset);//得到最小值
    	var max = d3.max(dataset);//得到最大值
    	var scaleLinear = d3.scaleLinear()
    		.domain([min,max])
    		.range([0,300]);
    	document.write("scaleLinear(1)输出："+scaleLinear(1));
    	d3.select("body").append("br");//换行
    	document.write("scaleLinear(2)输出："+scaleLinear(2));
    	d3.select("body").append("br");
    	document.write("scaleLinear(3.3)输出："+scaleLinear(3.3));
  </script>
  </body>
```

### 序数比例尺

domain 域和 range 域是离散的，也就是数组

```html
<body>
    <script>
    	var index = [0,1,2,3,4];
    	var color = ["red","blue","yellow","black","green"];
    	var scaleOrdinal = d3.scaleOrdinal()
    		.domain(index)
    		.range(color);
    	document.write("scaleOrdinal(1)输出："+scaleOrdinal(1));
    	d3.select("body").append("br");//换行
    	document.write("scaleOrdinal(2)输出："+scaleOrdinal(2));
    	d3.select("body").append("br");
    	document.write("scaleOrdinal(4)输出："+scaleOrdinal(4));
    </script>
  </body>
```

### 通过比例尺画矩形

```html
<body>
    <svg width="960" height="600"></svg>
    <script>
    	var marge = {top:60,bottom:60,left:60,right:60}
    	var dataset = [ 2.5 , 2.1 , 1.7 , 1.3 , 0.9 ];

    	//定义一个线性比例尺
    	var scaleLinear = d3.scaleLinear()
    		.domain([0,d3.max(dataset)])
    		.range([0,300]);

    	var svg = d3.select("svg");
    	var g = svg.append("g")
    		.attr("transform","translate("+marge.top+","+marge.left+")");

    	var rectHeight = 30;

    	g.selectAll("rect")
    		.data(dataset)
    		.enter()
    		.append("rect")
    		.attr("x",20)
    		.attr("y",function(d,i){
    			return i*rectHeight;
    		})
    		.attr("width",function(d){
    			return scaleLinear(d);//设置宽,并在这里使用比例尺
    		})
    		.attr("height",rectHeight-5)
        .attr("fill","blue");


        // -------------

    	//为坐标轴定义一个线性比例尺
    	var xScale = d3.scaleLinear()
    		.domain([0,d3.max(dataset)])
    		.range([0,250]);
    	//定义一个坐标轴
    	var xAxis = d3.axisBottom(xScale)//定义一个axis，由bottom可知，是朝下的
    		.ticks(7);//设置刻度数目
    	g.append("g")
    		.attr("transform","translate("+20+","+(dataset.length*rectHeight)+")")
    		.call(xAxis);


    </script>
  </body>
```

## 坐标轴

定义一个坐标轴

坐标轴是有朝向的，在这里我们以向下朝向、水平方向的坐标轴为例，其他朝向的（比如向左朝向的、垂直的坐标轴）类似

```js
//为坐标轴定义一个线性比例尺
var xScale = d3
  .scaleLinear()
  .domain([0, d3.max(dataset)])
  .range([0, 250]);
//定义一个坐标轴
var xAxis = d3
  .axisBottom(xScale) //定义一个axis，由bottom可知，是朝下的
  .ticks(7); //设置刻度数目
g.append("g")
  .attr(
    "transform",
    "translate(" + 20 + "," + dataset.length * rectHeight + ")"
  )
  .call(xAxis);
```

### 完整代码

```html
<!DOCTYPE html>
<html>
  <head>
    <title>testD3_chp9_1.html</title>

	<script type="text/javascript" src="http://d3js.org/d3.v5.min.js">
	</script>
    <!--<link rel="stylesheet" type="text/css" href="./styles.css">-->

  </head>

  <body>
    <svg width="960" height="600"></svg>
    <script>
    	var marge = {top:60,bottom:60,left:60,right:60}
    	var svg = d3.select("svg");//得到SVG画布
    	var width = svg.attr("width");//得到画布的宽
    	var height = svg.attr("height");//得到画布的长
    	var g = svg.append("g")
    		.attr("transform","translate("+marge.top+","+marge.left+")");

    	var dataset = [10,20,30,23,13,40,27,35,20];

    	var xScale = d3.scaleBand()
    		.domain(d3.range(dataset.length))
    		.rangeRound([0,width-marge.left-marge.right]);
    	var xAxis = d3.axisBottom(xScale);

    	var yScale = d3.scaleLinear()
    		.domain([0,d3.max(dataset)])
    		.range([height-marge.top-marge.bottom,0]);
    	var yAxis = d3.axisLeft(yScale);

    	g.append("g")
    		.attr("transform","translate("+0+","+(height-marge.top-marge.bottom)+")")
    		.call(xAxis);
    	g.append("g")
    		.attr("transform","translate(0,0)")
    		.call(yAxis);

    	//绘制矩形和文字
    	var gs = g.selectAll(".rect")
    		.data(dataset)
    		.enter()
    		.append("g");

    	//绘制矩形
    	var rectPadding = 20;//矩形之间的间隙
    	gs.append("rect")
    		.attr("x",function(d,i){
    			return xScale(i)+rectPadding/2;
    		})
    		.attr("y",function(d){
    			return yScale(d);
    		})
    		.attr("width",function(){
    			return xScale.step()-rectPadding;
    		})
    		.attr("height",function(d){
    			return height-marge.top-marge.bottom-yScale(d);
    		})
    		.attr("fill","blue");
    	//绘制文字
    	gs.append("text")
    		.attr("x",function(d,i){
    			return xScale(i)+rectPadding/2;
    		})
    		.attr("y",function(d){
            return yScale(d);
        	})
        	.attr("dx",function(){
        		(xScale.step()-rectPadding)/2;
        	})
        	.attr("dy",20)
        	.text(function(d){
        		return d;
        	})
    </script>
  </body>
</html>
```

## 让图表动起来

```js
.attr(xxx) .transition() .attr(xxx)，transition()表示添加过渡，也就是从前一个属性过渡到后一个属性
	.duration(2000)，表示过渡时间持续2秒
	.delay(500)，表示延迟0.4秒后再进行过渡
  .ease(d3.easeElasticInOut)表示过渡方式，注意这里和v3版本的区别
```

给矩形添加动画

```js
gs.append("rect")
  .attr("x", function(d, i) {
    return xScale(i) + rectPadding / 2;
  })
  .attr("y", function(d) {
    //这里是要改变的，即初始状态
    var min = yScale.domain()[0];
    return yScale(min); //可以得知，这里返回的是最大值
  })
  .attr("width", function() {
    return xScale.step() - rectPadding;
  })
  .attr("height", function(d) {
    //这里要改变，即初始状态
    return 0;
  })
  .attr("fill", "blue")
  .transition() //添加过渡
  .duration(2000) //持续时间
  .delay(function(d, i) {
    //延迟
    return i * 400;
  })
  //.ease(d3.easeElasticInOut)//这里读者可以自己将注释去掉，看看效果（chrome浏览器会报错，但是不影响效果）
  .attr("y", function(d) {
    //回到最终状态
    return yScale(d);
  })
  .attr("height", function(d) {
    //回到最终状态
    return height - marge.top - marge.bottom - yScale(d);
  });

//文字也添加动画

gs.append("text")
  .attr("x", function(d, i) {
    return xScale(i) + rectPadding / 2;
  })
  .attr("y", function(d) {
    var min = yScale.domain()[0];
    return yScale(min);
  })
  .attr("dx", function() {
    (xScale.step() - rectPadding) / 2;
  })
  .attr("dy", 20)
  .text(function(d) {
    return d;
  })
  .transition()
  .duration(2000)
  .delay(function(d, i) {
    return i * 400;
  })
  //.ease(d3.easeElasticInOut)
  .attr("y", function(d) {
    return yScale(d);
  });
```

## 事件监听

- click：鼠标单击某元素时触发，相当于 mousedown 和 mouseup 的组合
- mouseover：鼠标放在某元素上触发
- mouseout：鼠标移出某元素时触发
- mousemove：鼠标移动时触发
- mousedown：鼠标按钮被按下时触发
- mouseup：鼠标按钮被松开时触发
- dblclick：鼠标双击时触发

查看监听事件

```js
.on("click",function(){
    			console.log(d3.event);
    		})
```

为柱状图添加监听事件

```js
.on("mouseover",function(){
    			var rect = d3.select(this)
    				.transition()
    				.duration(1500)//当鼠标放在矩形上时，矩形变成黄色
    				.attr("fill","yellow");
    		})
    		.on("mouseout",function(){
    			var rect = d3.select(this)
    				.transition()
    				.delay(1500)
    				.duration(1500)//当鼠标移出时，矩形变成蓝色
    				.attr("fill","blue");
    		})
```

## 画饼图

```js
   rectArc() {


      var marge = { top: 60, bottom: 60, left: 60, right: 60 }
      var svg = d3.select("#testSvg_arc")
      var width = svg.attr("width")
      var height = svg.attr("height")
      var g = svg.append("g")
        .attr("transform", "translate(" + marge.top + "," + marge.left + ")");

      var dataset = [30, 10, 43, 55, 13];//需要将这些数据变成饼状图的数据

      //设置一个color的颜色比例尺，为了让不同的扇形呈现不同的颜色
      var colorScale = d3.scaleOrdinal()
        .domain(d3.range(dataset.length))
        .range(d3.schemeCategory10);

      //新建一个饼状图
      var pie = d3.pie();
      //将原始数据变成可以绘制饼状图的数据，
      var pieData = pie(dataset);

      //在浏览器的控制台打印pieData
      console.log(pieData);


      //新建一个弧形生成器
      var innerRadius = 0;//内半径
      var outerRadius = 100;//外半径
      var arc_generator = d3.arc()
        .innerRadius(0)
        .outerRadius(100);

      var gs = g.selectAll(".g")
        .data(pieData)
        .enter()
        .append("g")
        .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")//位置信息

      //绘制饼状图的各个扇形
      gs.append("path")
        .attr("d", function (d) {
          return arc_generator(d);//往弧形生成器中出入数据
        })
        .attr("fill", function (d, i) {
          return colorScale(i);//设置颜色
        });


        //绘制饼状图上面的文字信息
    	gs.append("text")
    		.attr("transform",function(d){//位置设在中心处
    			return "translate("+arc_generator.centroid(d)+")";
    		})
    		.attr("text-anchor","middle")
    		.text(function(d){
    			return d.data;
    		})

    },
```

### 添加图片

```js
gs.append("image")
  .attr("width", 77)
  .attr("height", 90)
  // .attr("x", -35)
  // .attr("y", 20)
  .attr("xlink:href", function(d) {
    return "/static/suyu.png";
    // return d.image;
  });
```
